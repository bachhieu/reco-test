/* !!
 * Code generated by fkit
 * If you need to write additional functions, should create a separate file.
 * File Created: Sunday, 27 April 2025 14:28:41 +07:00
 * Author: VietLD (leduyviet2612@gmail.com)
 * -----
 * Last Modified: Sunday, 27 April 2025 14:28:41 +07:00
 * Modified By: HIEUBV\hieubv
 * -----
 * Copyright 2025. All rights reserved.
 */

package postgres_dao

import (
	"strings"

	sq "github.com/Masterminds/squirrel"

	"github.com/bachhieu/fountain/baselib/sql_client"
	"github.com/bachhieu/fountain/baselib/v_log"
	"github.com/bachhieu/test/biz/dal/do/user_do"
	"github.com/bachhieu/test/biz/dal/models"
	"github.com/jmoiron/sqlx"
)

var (
	users_table  = "users"
	users_fields = []string{
		"id", "username", "email", "password_hash", "full_name", "role", "provider", "created_time", "updated_time",
	}
)

func usersToMap(record *models.UserMD) map[string]interface{} {
	return map[string]interface{}{
		"id":            record.ID,
		"username":      record.Username,
		"email":         record.Email,
		"password_hash": record.PasswordHash,
		"full_name":     record.FullName,
		"role":          record.Role,
		"provider":      record.Provider,
		"created_time":  record.CreatedTime,
		"updated_time":  record.UpdatedTime,
	}
}

type UsersDAO struct {
	*sqlx.DB
}

func NewUsersDAO(DB *sqlx.DB) *UsersDAO {
	return &UsersDAO{DB}
}

func (dao *UsersDAO) Insert(record *models.UserMD, opts ...Option) error {
	builder := sq.Insert(users_table).SetMap(usersToMap(record))

	sqlQuery, args, err := builder.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Insert - Lỗi xây dựng truy vấn: %+v", err)
		return err
	}

	_, err = ExecWithTx(dao.DB, opts, sqlQuery, args...)
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Insert - Lỗi thực thi truy vấn: %+v", err)
		return err
	}

	return nil
}

func (dao *UsersDAO) BatchInsert(records []*models.UserMD, opts ...Option) error {
	builder := sq.Insert(users_table).
		Columns(users_fields...)
	for _, record := range records {
		builder = builder.SetMap(usersToMap(record))
	}

	sqlQuery, args, err := builder.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::BatchInsert - Lỗi xây dựng truy vấn: %+v", err)
		return err
	}

	if _, err := ExecWithTx(dao.DB, opts, sqlQuery, args...); err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::BatchInsert - Lỗi thực thi truy vấn: %+v", err)
		return err
	}

	return nil
}

func (dao *UsersDAO) BatchUpsert(records []*models.UserMD, opts ...Option) error {
	builder := sq.Insert(users_table).
		Columns(users_fields...)

	for _, record := range records {
		builder = builder.Values(
			record.ID,
			record.Username,
			record.Email,
			record.PasswordHash,
			record.FullName,
			record.Role,
			record.Provider,
			record.CreatedTime,
			record.UpdatedTime,
		)
	}

	//TODO: Sửa lại ON CONFLICT sẽ dựa trên các trường cần thiết
	builder = builder.Suffix(`ON CONFLICT (id) DO UPDATE SET
		username = EXCLUDED.username,
		email = EXCLUDED.email,
		password_hash = EXCLUDED.password_hash,
		full_name = EXCLUDED.full_name,
		role = EXCLUDED.role,
		provider = EXCLUDED.provider,
		created_time = EXCLUDED.created_time,
		updated_time = EXCLUDED.updated_time`)

	sqlQuery, args, err := builder.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::BatchUpsert - Lỗi xây dựng truy vấn: %+v", err)
		return err
	}

	if _, err := ExecWithTx(dao.DB, opts, sqlQuery, args...); err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::BatchUpsert - Lỗi thực thi truy vấn: %+v", err)
		return err
	}

	return nil
}

func (dao *UsersDAO) Upsert(record *models.UserMD, opts ...Option) error {
	builder := sq.Insert(users_table).SetMap(usersToMap(record)).
		Suffix(`ON CONFLICT (id) DO UPDATE SET
		username = EXCLUDED.username,
		email = EXCLUDED.email,
		password_hash = EXCLUDED.password_hash,
		full_name = EXCLUDED.full_name,
		role = EXCLUDED.role,
		provider = EXCLUDED.provider,
		created_time = EXCLUDED.created_time,
		updated_time = EXCLUDED.updated_time`)

	sqlQuery, args, err := builder.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Upsert - Lỗi xây dựng truy vấn: %+v", err)
		return err
	}

	_, err = ExecWithTx(dao.DB, opts, sqlQuery, args...)
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Upsert - Lỗi thực thi truy vấn: %+v", err)
		return err
	}

	return nil
}

func (dao *UsersDAO) Get(id string, opts ...Option) *models.UserMD {
	queryBuilder := sq.Select(users_fields...).
		From(users_table).
		Where(sq.Eq{"id": id})

	query, args, err := queryBuilder.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Get - Lỗi xây dựng truy vấn: %+v", err)
		return nil
	}

	do, err := sql_client.QueryDataParser[models.UserMD](dao.DB, query, nil, args...)
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Get - Lỗi thực thi truy vấn: %+v", err)
		return nil
	}

	return do
}

func (dao *UsersDAO) GetByEmail(email string) *models.UserMD {
	queryBuilder := sq.Select(users_fields...).
		From(users_table).
		Where(sq.Eq{"email": email})

	query, args, err := queryBuilder.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Get - Lỗi xây dựng truy vấn: %+v", err)
		return nil
	}

	do, err := sql_client.QueryDataParser[models.UserMD](dao.DB, query, nil, args...)
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Get - Lỗi thực thi truy vấn: %+v", err)
		return nil
	}

	return do
}

func (dao *UsersDAO) GetMany(ids []string, opts ...Option) ([]*models.UserMD, error) {
	queryBuilder := sq.Select(users_fields...).
		From(users_table).
		Where(sq.Eq{"id": ids})

	query, args, err := queryBuilder.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::GetMany - Error building query: %+v", err)
		return nil, err
	}

	res, err := sql_client.QueryListDataParser[models.UserMD](dao.DB, query, nil, args...)
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::GetMany - Error executing query: %+v", err)
		return nil, err
	}

	return res, nil
}

func (dao *UsersDAO) GetAll(opts ...Option) []*models.UserMD {
	queryBuilder := sq.Select(users_fields...).
		From(users_table).
		OrderBy("created_time ASC")

	query, args, err := queryBuilder.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::GetAll - Lỗi xây dựng truy vấn: %+v", err)
		return nil
	}

	res, err := sql_client.QueryListDataParser[models.UserMD](dao.DB, query, nil, args...)
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::GetAll - Lỗi thực thi truy vấn: %+v", err)
		return nil
	}

	return res
}

func (dao *UsersDAO) Gets(params *user_do.UserQueryParams, offset, limit int, opts ...Option) ([]*models.UserMD, error) {
	queryBuilder := sq.Select(users_fields...).
		From(users_table)

	if params.Q != nil && *params.Q != "" {
		queryBuilder = queryBuilder.Where("LOWER(name) LIKE ?", "%"+strings.ToLower(*params.Q)+"%")
	}

	queryBuilder = queryBuilder.
		OrderBy("created_time ASC").
		Offset(uint64(offset)).
		Limit(uint64(limit))

	query, args, err := queryBuilder.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Gets - Error building query: %+v", err)
		return nil, err
	}

	res, err := sql_client.QueryListDataParser[models.UserMD](dao.DB, query, nil, args...)
	return res, err
}

func (dao *UsersDAO) Update(md *models.UserMD, opts ...Option) error {
	queryBuilder := sq.Update(users_table).
		SetMap(usersToMap(md)).
		Where(sq.Eq{"id": md.ID})

	sqlQuery, args, err := queryBuilder.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Update - Lỗi xây dựng truy vấn: %+v", err)
		return err
	}

	_, err = ExecWithTx(dao.DB, opts, sqlQuery, args...)
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Update - Lỗi thực thi truy vấn: %+v", err)
		return err
	}

	return nil
}
func (dao *UsersDAO) Delete(id string, opts ...Option) error {
	builder := sq.Delete(users_table).
		Where(sq.Eq{"id": id})

	query, args, err := builder.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Delete - Lỗi xây dựng truy vấn: %+v", err)
		return err
	}

	_, err = ExecWithTx(dao.DB, opts, query, args...)
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::Delete - Lỗi thực thi truy vấn: %+v", err)
		return err
	}

	return nil
}

func (dao *UsersDAO) CountTotal(params *user_do.UserQueryParams, opts ...Option) int {
	queryBuilder := sq.Select("COUNT(1)").
		From(users_table)

	if params.Q != nil && *params.Q != "" {
		queryBuilder = queryBuilder.Where("LOWER(name) LIKE ?", "%"+strings.ToLower(*params.Q)+"%")
	}

	query, args, err := queryBuilder.PlaceholderFormat(sq.Dollar).ToSql()
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::CountTotal - Error building query: %+v", err)
		return 0
	}

	var count int
	err = dao.DB.QueryRow(query, args...).Scan(&count)
	if err != nil {
		v_log.V(1).WithError(err).Errorf("UsersDAO::CountTotal - Error executing query: %+v", err)
		return 0
	}

	return count
}
